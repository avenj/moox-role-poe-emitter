=pod

=head1 NAME

MooX::Role::POE::Emitter::Tutorial

=head1 SYNOPSIS

A L<MooX::Role::POE::Emitter> walk-through aimed at developers who may not 
have strong POE/Moo(se) background.

Some familiarity with object-oriented concepts is assumed.

=head1 INTRODUCTION

There are a few concepts and modules you will want to review prior to 
implementing this role:

=head2 Moo

L<Moo> is a minimalist alternative to L<Moose>, providing all the 
class-building goodies in a L<Moose> compatible way without the extra 
overhead of a Meta-Object Protocol (MOP).

See L<Moo> for details.

=head2 Roles

A role is a well-defined implementation of what some languages call 
"mix-ins" or sometimes possibly "traits." A role defines something a class 
B<does>; in other words, encapsulated methods & attributes that do not form 
a concrete class on their own, but can be "consumed" by a class to add some 
behavior (such as "emits events").

See L<Moo::Role> and L<Role::Tiny> for details.

=head2 POE

L<POE> is a framework for event-driven asynchronous systems; it is the 
granddaddy of Perl event frameworks.

L<http://poe.perl.org> contains extensive documentation and examples.

L<POE>, L<POE::Kernel>, and L<POE::Session> are helpful reads, at the very 
least.

=head3 POE Kernel

The L<POE::Kernel> is a bit like an operating system kernel, 
managing the L<POE::Loop> and providing central bookkeeping and 
event/signal dispatch functionality.

=head3 POE Sessions

We stated above that the L<POE::Kernel> is conceptually similar to an 
operating system kernel. In that sense, a L<POE::Session> could be thought 
of as being like a process -- the Session asynchronously receives events 
(often called "states") posted to it by itself or other Sessions and 
performs some action defined in an assigned handler.

These handlers or 'states' are defined via POE mechanisms known as 
C<inline_states> (states assigned to inlined coderefs), C<package_states> 
(states assigned to a particular package name), and (most importantly for 
our purposes) C<object_states>. See L</Adding Emitter states> for more on 
C<object_states> as pertains to your Emitter and the L<POE::Session> 
documentation for the details.

L<POE> events are typically sent asynchronously between Sessions in a 
one-to-one manner; 
L<MooX::Role::POE::Emitter> makes it possible to post events to an 
arbitrary number of interested "listener" Sessions in a one-to-many fashion 
instead.

Your Emitter is automatically given its own L<POE::Session> when it is 
started. Sessions that have already been defined are run when 
L<POE::Kernel>'s C<run()> method is called; Sessions can be created on the 
fly, as well, in which case they are spawned when they are created via 
L<POE::Session>'s C<create()> method.

FIXME note about named arguments? somewhere ...

=head2 Observer Pattern

The design pattern implemented in this Role is described as "Observer 
Pattern" -- a term for a design approach in which "observer" 
objects are automatically notified/updated when another object changes 
state.

This particular implementation is derived from 
L<POE::Component::Syndicator>-0.06.

=head1 EMITTERS

=head2 Outline

Since this is a Role, not a class unto itself, the first step in creating 
an Emitter is to define your class:

  package My::Emitter;
  use Moo;
  use POE;
  with 'MooX::Role::POE::Emitter';

The above snippet is actually enough to have a working Emitter with default 
options and no built-in states; you could just stop reading right there ;-)

=head2 Configuration

That might not be quite enough; we may want named L<POE> states built 
into our Emitter that we can trigger, and/or we may want to change some 
configuration options, assign an C<alias> that L<POE> will 
recognize, etc.

=head3 BUILD vs construction-time

There are a couple different approaches to configuring your Emitter.

Your Emitter could define a C<BUILD> method or some other method (the 
SYNOPSIS of L<MooX::Role::POE::Emitter> uses C<spawn>) that performs some 
set-up after the object is constructed. Here's an example that adds a 
handler for the internal 'emitter_started' L<POE> event dispatched to the 
Emitter when it is started; we'll go into more depth on C<object_states> 
later:

  package My::Emitter;
  use Moo;
  use POE;
  with 'MooX::Role::POE::Emitter';

  sub BUILD {
    my ($self) = @_;

    ## Add some object_states, for example
    ## We'll cover this further later on.
    $self->set_object_states(
      [
        $self => {
          'emitter_started' => '_emitter_started',
        },

        ## Include any object_states that were added at
        ## construction time (or by a subclass, etc)
        (
          $self->has_object_states ?
            @{ $self->object_states } : ()
        ),
      ],
    );
  }
  
  sub spawn {
    my ($self) = @_;
    ## Start our Emitter's Session. We could do this in BUILD to cause the
    ## Session to be immediately created, but providing a spawn() method
    ## gives us a little more external control:
    $self->_start_emitter;
  }

  sub _emitter_started {
    my ($kernel, $self) = @_[KERNEL, OBJECT];
    ## Our Emitter's Session has started.
    ## Do some initialization within our Emitter, for example
  }

FIXME notes on construction-time configuration
FIXME link to attribs in MXR::P::E docs

=head3 Setting an alias

Giving your Emitter's L<POE::Session> a human-parsable L<POE> C<alias> can 
make it easier to post events without directly keeping track of your 
Emitter's object. This is something you might normally do at 
construction time / before spawn-time from whatever external 
controller/frontend spawns the Emitter:

  ## From a frontend or controller of some sort, for example
  my $emitter = My::Emitter->new(
    alias => 'my_emitter',
  );

(If it is not set, it will default to the 'stringified' representation of 
your Emitter's object.)

You can always retrieve the current alias given the Emitter's object via 
the C<alias> attribute:

  my $alias = $emitter->alias;

This can be used to post events to the Emitter:

  ## Like calling emit(), but using POE dispatch directly:
  my $alias = $emitter->alias;
  $poe_kernel->post( $alias, 'emit', $event, @args );

... as can the L<POE::Session>'s C<session_id> of a running Emitter:

  my $sess_id = $emitter->session_id;
  $poe_kernel->post( $sess_id, 'emit', $event, @args );

The C<alias> can be reset on-the-fly, but there are few cases where that is 
very useful:

  $emitter->set_alias( $new_alias );

=head3 Configuring prefixes

FIXME

=head3 Adding Emitter states

FIXME demonstrate object_states
FIXME note about dispatch to Emitter session if registered

=head2 Starting your Emitter

FIXME _start_emitter, link back to POE section note about POE::Kernel->run
FIXME _emitter_started

=head2 Emitting events

FIXME emit, emit_now, process, retvals

=head2 Dispatch within the Emitter

FIXME yield, call, anon CBs, mention ->timer($delay, 'emit', $event) etc

=head3 Timers

=head2 Stopping your Emitter

FIXME show how to define a ->shutdown() method

FIXME shutdown_emitter events, ->_stop_emitter

=head1 PLUGINS

FIXME brief outline and links back to MooX::Role::Pluggable

=head2 Writing a plugin

=head2 Adding plugins

=head1 LISTENERS

=head2 Creating a listener Session

=head2 Subscribing to emitted events

=head2 Receiving events

=head1 COMPLETION

FIXME full app, test it

=head1 AUTHOR

Jon Portnoy <avenj@cobaltirc.org>

=cut
