=pod

=head1 NAME

MooX::Role::POE::Emitter::Tutorial

=head1 SYNOPSIS

A L<MooX::Role::POE::Emitter> walk-through aimed at developers who may not 
have strong POE/Moo(se) background.

Some familiarity with object-oriented concepts is assumed.

=head1 INTRODUCTION

There are a few concepts and modules you will want to review prior to 
using this role in your class(es):

=head2 Moo

L<Moo> is a minimalist alternative to L<Moose>, providing all the 
class-building goodies in a L<Moose>-compatible manner without the extra 
overhead of a Meta-Object Protocol (MOP).

See L<Moo> for details.

=head2 Roles

A role is a well-defined implementation of what some languages call 
"mix-ins" or sometimes possibly "traits." A role defines something a class 
B<does>; in other words, encapsulated methods & attributes that do not form 
a concrete class on their own, but can be "consumed" by a class to add some 
behavior (such as "emits events").

See L<Moo::Role> and L<Role::Tiny> for details.

=head2 POE

L<POE> is a framework for event-driven asynchronous systems; it is the 
granddaddy of Perl event frameworks.

L<http://poe.perl.org> contains extensive documentation and examples.

L<POE>, L<POE::Kernel>, and L<POE::Session> are helpful reads, at the very 
least.

=head3 POE Kernel

The L<POE::Kernel> is a bit like an operating system kernel, 
managing the L<POE::Loop> and providing central bookkeeping and 
event/signal dispatch functionality.

=head3 POE Sessions

We stated above that the L<POE::Kernel> is conceptually similar to an 
operating system kernel. In that sense, a L<POE::Session> could be thought 
of as being like a process -- the Session asynchronously receives events 
(often called "states") posted to it by itself or other Sessions and 
performs some action defined in an assigned handler.

These handlers or 'states' are defined via POE mechanisms known as 
C<inline_states> (states assigned to inlined coderefs), C<package_states> 
(states assigned to a particular package name), and (most importantly for 
our purposes) C<object_states>. See L</Adding Emitter states> for more on 
C<object_states> as pertains to your Emitter and the L<POE::Session> 
documentation for the details.

L<POE> events are typically sent asynchronously between Sessions in a 
one-to-one manner; 
L<MooX::Role::POE::Emitter> makes it possible to post events to an 
arbitrary number of interested "listener" Sessions in a one-to-many fashion 
instead.

Your Emitter is automatically given its own L<POE::Session> when it is 
started. Sessions that have already been defined are run when 
L<POE::Kernel>'s C<run()> method is called; Sessions can be created on the 
fly, as well, in which case they are spawned when they are created via 
L<POE::Session>'s C<create()> method.

=head2 Observer Pattern

The design pattern implemented in this Role is described as "Observer 
Pattern" -- a term for a design approach in which "observer" 
objects are automatically notified/updated when another object changes 
state.

This particular implementation is derived from 
L<POE::Component::Syndicator>-0.06.

=head1 EMITTERS

=head2 Outline

Since this is a Role, not a class unto itself, the first step in creating 
an Emitter is to define your class:

  package My::Emitter;
  use Moo;
  use POE;
  with 'MooX::Role::POE::Emitter';

The above snippet is actually enough to have a working Emitter with default 
options and no built-in states; you could just stop reading right there ;-)

=head2 Configuration

That might not be quite enough; we may want named L<POE> states built 
into our Emitter that we can trigger, and/or we may want to change some 
configuration options, assign an C<alias> that L<POE> will 
recognize, etc.

=head3 BUILD vs construction-time

There are a couple different approaches to configuring your Emitter.

Your Emitter could define a C<BUILD> method or some other method (the 
SYNOPSIS of L<MooX::Role::POE::Emitter> uses C<spawn>) that performs some 
set-up after the object is constructed. Here's an example that adds a 
handler for the internal 'emitter_started' L<POE> event dispatched to the 
Emitter when it is started and one that does something silly; we'll go into 
more depth on C<object_states> later:

  package My::Emitter;
  use Moo;
  use POE;
  with 'MooX::Role::POE::Emitter';

  sub BUILD {
    my ($self) = @_;

    ## Add some object_states, for example
    ## We'll cover this further later on.
    $self->set_object_states(
      [
        $self => {
          'emitter_started' => 'p_emitter_started',
          'increment_count' => 'p_increment_count',
        },

        ## Include any object_states that were added at
        ## construction time (or by a subclass, etc)
        (
          $self->has_object_states ?
            @{ $self->object_states } : ()
        ),
      ],
    );
  }
  
  sub spawn {
    my ($self) = @_;
    ## Start our Emitter's Session. We could do this in BUILD to cause the
    ## Session to be immediately created, but providing a spawn() method
    ## gives us a little more external control:
    $self->_start_emitter;
  }

  sub p_emitter_started {
    my ($kernel, $self) = @_[KERNEL, OBJECT];
    ## Our Emitter's Session has started.
    ## Do some initialization within our Emitter, for example
  }

  sub p_increment_count {
    my ($kernel, $self) = @_[KERNEL, OBJECT];
    $_[HEAP]->{count} += $_[ARG0] || 1;
    $self->emit( 'counter_incremented', $_[HEAP]->{count} );
  }

Of course, it is still possible to pass in attribute definitions at 
construction time:

  ## In a frontend, for example
  ## Set an alias and a plugin registration prefix:
  my $emitter = My::Emitter->new(
    alias  => 'MyEmitter',
    register_prefix => 'Plug_',
  );

See L<MooX::Role::POE::Emitter/"Attributes"> for more details on 
configuration-related attributes.

=head3 Setting an alias

Giving your Emitter's L<POE::Session> a human-parsable L<POE> C<alias> can 
make it easier to post events without directly keeping track of your 
Emitter's object. This is something you might normally do at 
construction time / before spawn-time from whatever external 
controller/frontend spawns the Emitter:

  ## From a frontend or controller of some sort, for example:
  my $emitter = My::Emitter->new(
    alias => 'my_emitter',
  );

(If an alias is not set, it will default to the 'stringified' 
representation of your Emitter's object.)

You can always retrieve the current alias given the Emitter's object via 
the C<alias> attribute:

  my $alias = $emitter->alias;

This can be used to post events to the Emitter:

  ## Like calling emit(), but using POE dispatch directly:
  my $alias = $emitter->alias;
  $poe_kernel->post( $alias, 'emit', $event, @args );

... as can the L<POE::Session>'s C<session_id> of a running Emitter:

  my $sess_id = $emitter->session_id;
  $poe_kernel->post( $sess_id, 'emit', $event, @args );

The C<alias> can be reset on-the-fly, if needed:

  $emitter->set_alias( $new_alias );

=head3 Configuring prefixes

Your emitter has a few different prefix types that are configurable:

=over

=item event_prefix

The B<event_prefix> is prepended to emitted events that 
are dispatched to subscribed listening Sessions.

For example, if B<event_prefix> is 'emitted_' (the default prefix), 
C<$emitter->emit('my_event')> will dispatch 'emitted_my_event' to 
subscribed listener sessions.

=item register_prefix

The B<register_prefix> is the prefix prepended to registration events; this 
is really for use by L<MooX::Role::Pluggable> (see 
L</MooX::Role::Pluggable/"_pluggable_init"> for more details) -- the 
B<register_prefix> is prepended to 'register' and 'unregister' events 
dispatched to plugins at load-time.

FIXME link to more on plugin register handlers in plugins section

=item pluggable_type_prefixes

FIXME quickly explain process() vs emit() + PROCESS vs NOTIFY
      links down to Plugin section and MooX::Role::Pluggable

=back

FIXME construction/config examples?

=head3 Adding Emitter states

Unless your class is just a bare Emitter intended to broadcast 
externally-fed events to plugins and listeners, it will probably do some 
work internally via its own states. At the very least, you might want to 
map the C<emitter_started> event to some handler.

Earlier, we showed an 'increment_count' state that was mapped to the 
'p_increment_count' method via C<object_states>. (It's important to note 
that these object_states have to be defined before C<_start_emitter> is 
called -- it's actually possible to execute anonymous code references as 
if they were predefined states, however; see L</"Dispatch within the 
Emitter">)

A POE handler looks a little different than the average subroutine; 
parameters are given names (that are actually constants imported when you 
C<use POE;>):

  sub my_event {
    ## The POE::Kernel and the object this event was dispatched to:
    my ($kernel, $self) = @_[KERNEL, OBJECT];
    ## The arguments passed to this event:
    my @params = @_[ARG0 .. $#_];
    . . .
  }

See L<POE::Session/"USING POE::Session"> from the POE documentation for 
more details on what a normal POE state belonging to a Session might look 
like.

There are sugary methods provided for triggering these Emitter states. 
L</"Dispatch within the Emitter"> contains most of the details.

=head2 Starting your Emitter

Your Emitter's L<POE::Session> is created when _start_emitter is called; a 
frequent pattern is to provide some method that specifically starts the 
Emitter:

  ## A spawn() method in your Emitter class:
  sub spawn {
    my ($self) = @_;
    $self->_start_emitter;
  }

The L<POE::Session> is spawned immediately if the L<POE::Kernel> is already 
running; otherwise it is spawned whenever L<POE::Kernel>'s C<run()> method 
is called (typically from a frontend of some sort or similar). Refer back 
to the section on L</POE> for details.

When the Emitter starts, it will issue itself an 'emitter_started' POE 
event with no arguments. In L</Configuration>, we demonstrated installing 
an 'emitter_started' handler via the C<object_states> attribute; refer back 
to that section for a brief example.

=head2 Emitting events

Once the Emitter's Session is started, your object can begin emitting 
events via C<emit()> (or its synchronous counterpart C<emit_now()>.

Any piece of code that knows about the Emitter object can tell it to emit 
arbitrary events to subscribed listeners:

  ## Dispatched asynchronously:
  $emitter->emit( $event, @args );
  ## Dispatched now:
  $emitter->emit( $event, @args );

Loading plugins is optional, but if they are loaded, emitted events 
are dispatched to the Emitter's session first, then to loaded 
plugins, then (if the event wasn't eaten by plugins FIXME link to 
plugins section) broadcast to subscribed listeners.

Emitted events are called "NOTIFY" events in conjunction with 
the plugin pipeline provided by L<MooX::Role::Pluggable> -- this is in 
contrast to "PROCESS" type events, which are plugin-processed 
immediately but never sent to subscribed 
listeners. See L<MooX::Role::POE::Emitter/"process"> and FIXME link to 
plugins section

=head2 Dispatch within the Emitter

Your Emitter comes with convenient methods for dispatching events within 
the context of the Emitter itself; that is to say, dispatching defined 
C<object_states> and even executing anonymous subroutines as if they were 
named POE states.

For example, our Emitter as shown in L</Configuration> defined an 
'increment_count' state and a handler for it that just increments a 
variable in the L<POE::Session>'s HEAP and emits 
'counter_incremented' with the new value as an argument.

We could externally invoke the Emitter's handler asynchronously via 
C<yield()>:

  $emitter->yield( 'increment_count', 2 );

... or synchronously via C<call()>:

  $emitter->call( 'increment_count', 2 );

Of course, this only works for POE states that are predefined in your 
Emitter. C<yield()> and C<call()> actually accept anonymous code references 
as well, which are executed just as if they were named states:

  ## Re-implement our increment_count state as a coderef:
  $emitter->yield(
    sub {
       ## $_[OBJECT] is our Emitter's object:
       my ($kernel, $self) = @_[KERNEL, OBJECT];
 
       ## $_[STATE] is this code reference itself:
       my $cb = $_[STATE];

       ## $_[HEAP] is our Emitter's POE::Session's heap:
       $_[HEAP]->{count} += $_[ARG0] || 1;
       $self->emit( 'counter_incremented', $_[HEAP]->{count} );
    },
    2
  );

=head3 Timers

The L<POE::Kernel> provides its own timer/delay mechanisms, but your 
Emitter comes with some sugar for issuing timed events that will execute in 
the context of the running Emitter.

For example, you can C<emit()> events on a timer:

  my $timer_id = $emitter->timer(
    $delay_seconds,
    'emit',
    $some_event,
    @event_args
  );

Perhaps your Emitter might have set up some C<object_states> for itself 
(refer back to L</Configuration>) and you'd like to fire one of your 
custom handlers at some point in the future:

  $emitter->timer( $delay, 'my_event', @args );

Just like C<yield>, C<timer> can take an anonymous callback code-reference 
instead, which will receive itself via $_[STATE]:

  $emitter->timer(
    $delay,
    sub {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      my $callback  = $_[STATE];
      my $first_arg = $_[ARG0];
      ## ... do some work, set $new_arg perhaps ...
      ## Reset this same timed callback, as an example:
      $self->timer( $delay, $callback, $new_arg );
    },
    $some_arg
  );

C<timer()> returns the timer ID, which can be fed to C<timer_del> to clear 
this timer if needed:

  $emitter->timer_del( $timer_id );

FIXME mention emitted notifications

=head2 Stopping your Emitter

Unlike a normal L<POE::Session>, which goes away if it has no alias and 
nothing to do, your Emitter's Session only shuts down when it is told to.

To make clean shutdowns easier, your Emitter may want to provide a 
C<shutdown> method or similar that calls C<_shutdown_emitter> (and perhaps 
does some other cleanup):

  ## In your Emitter:
  sub shutdown {
    my ($self) = @_;
    ## Do other cleanup, etc.
    $self->_shutdown_emitter;
  }

Calling C<_shutdown_emitter> will unregister subscribed listening Sessions, 
stop timers, clear the plugin pipeline, and reduce the Emitter's L<POE> 
reference count so that the Session can go away naturally.

FIXME dispatched shutdown-related events
FIXME shutdown_emitter events, ->_shutdown_emitter

=head1 PLUGINS

Since consuming L<MooX::Role::POE::Emitter> also brings in 
L<MooX::Role::Pluggable>, your Emitter comes with a plugin pipeline and 
various methods to manipulate it, which are documented in 
L<MooX::Role::Pluggable>.

Plugins are an optional way to extend your Emitter on-the-fly. Plugin 
objects can control an event's lifetime and modify arguments (or even drop 
events entirely) prior to broadcasting events to subscribed listener 
Sessions.

=head2 Adding plugins to the Emitter

FIXME brief plugin_add/plugin_del coverage, emitted plugin_added?

=head2 PROCESS vs NOTIFY

=head2 Pluggable handler arguments

FIXME notes on modifying arguments, references, etc

=head2 Controlling event lifetime

FIXME brief notes on EAT_* constants


=head2 Writing a plugin

FIXME brief example with register handlers and a P_ / N_ handler

=head1 LISTENERS

=head2 Creating a listener Session

FIXME

=head2 Subscribing to emitted events

FIXME

=head2 Receiving events

FIXME

=head1 AUTHOR

Jon Portnoy <avenj@cobaltirc.org>

=cut
