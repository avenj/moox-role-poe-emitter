=pod

=head1 NAME

MooX::Role::POE::Emitter::Tutorial

=head1 SYNOPSIS

A L<MooX::Role::POE::Emitter> walk-through aimed at developers who may not 
have strong POE/Moo(se) background.

Some familiarity with object-oriented concepts is assumed.

=head1 INTRODUCTION

There are a few concepts and modules you will want to review prior to 
using this role in your class(es):

=head2 Moo

L<Moo> is a minimalist alternative to L<Moose>, providing all the 
class-building goodies in a L<Moose>-compatible manner without the extra 
overhead of a Meta-Object Protocol (MOP).

See L<Moo> for details.

=head2 Roles

A role is a well-defined implementation of what some languages call 
"mix-ins" or sometimes possibly "traits." A role defines something a class 
B<does>; in other words, encapsulated methods & attributes that do not form 
a concrete class on their own, but can be "consumed" by a class to add some 
behavior (such as "emits events").

See L<Moo::Role> and L<Role::Tiny> for details.

=head2 POE

L<POE> is a framework for event-driven asynchronous systems; it is the 
granddaddy of Perl event frameworks.

L<http://poe.perl.org> contains extensive documentation and examples.

L<POE>, L<POE::Kernel>, and L<POE::Session> are helpful reads, at the very 
least.

=head3 POE Kernel

The L<POE::Kernel> is a bit like an operating system kernel, 
managing the L<POE::Loop> and providing central bookkeeping and 
event/signal dispatch functionality.

=head3 POE Sessions

We stated above that the L<POE::Kernel> is conceptually similar to an 
operating system kernel. In that sense, a L<POE::Session> could be thought 
of as being like a process -- the Session asynchronously receives events 
(often called "states") posted to it by itself or other Sessions and 
performs some action defined in an assigned handler.

These handlers or 'states' are defined via POE mechanisms known as 
C<inline_states> (states assigned to inlined coderefs), C<package_states> 
(states assigned to a particular package name), and (most importantly for 
our purposes) C<object_states>. See L</Adding Emitter states> for more on 
C<object_states> as pertains to your Emitter and the L<POE::Session> 
documentation for the details.

L<POE> events are typically sent asynchronously between Sessions in a 
one-to-one manner; 
L<MooX::Role::POE::Emitter> makes it possible to post events to an 
arbitrary number of interested "listener" Sessions in a one-to-many fashion 
instead.

Your Emitter is automatically given its own L<POE::Session> when it is 
started. Sessions that have already been defined are run when 
L<POE::Kernel>'s C<run()> method is called; Sessions can be created on the 
fly, as well, in which case they are spawned when they are created via 
L<POE::Session>'s C<create()> method.

=head2 Observer Pattern

The design pattern implemented in this Role is described as "Observer 
Pattern" -- a term for a design approach in which "observer" 
objects are automatically notified/updated when another object changes 
state.

This particular implementation is derived from 
L<POE::Component::Syndicator>-0.06.

=head1 EMITTERS

=head2 Outline

Since this is a Role, not a class unto itself, the first step in creating 
an Emitter is to define your class:

  package My::Emitter;
  use Moo;
  use POE;
  with 'MooX::Role::POE::Emitter';

The above snippet is actually enough to have a working Emitter with default 
options and no built-in states; you could just stop reading right there ;-)

=head2 Configuration

That might not be quite enough; we may want named L<POE> states built 
into our Emitter that we can trigger, and/or we may want to change some 
configuration options, assign an C<alias> that L<POE> will 
recognize, etc.

=head3 BUILD vs construction-time

There are a couple different approaches to configuring your Emitter.

Your Emitter could define a C<BUILD> method or some other method (the 
SYNOPSIS of L<MooX::Role::POE::Emitter> uses C<spawn>) that performs some 
set-up after the object is constructed. Here's an example that adds a 
handler for the internal 'emitter_started' L<POE> event dispatched to the 
Emitter when it is started and one that does something silly; we'll go into 
more depth on C<object_states> later:

  package My::Emitter;
  use Moo;
  use POE;
  with 'MooX::Role::POE::Emitter';

  sub BUILD {
    my ($self) = @_;

    ## Add some object_states, for example
    ## We'll cover this further later on.
    $self->set_object_states(
      [
        $self => {
          'emitter_started' => 's_emitter_started',
          'increment_count' => 's_increment_count',
        },

        ## Include any object_states that were added at
        ## construction time (or by a subclass, etc)
        (
          $self->has_object_states ?
            @{ $self->object_states } : ()
        ),
      ],
    );
  }
  
  sub spawn {
    my ($self) = @_;
    ## Start our Emitter's Session. We could do this in BUILD to cause the
    ## Session to be immediately created, but providing a spawn() method
    ## gives us a little more external control:
    $self->_start_emitter;
  }

  sub s_emitter_started {
    my ($kernel, $self) = @_[KERNEL, OBJECT];
    ## Our Emitter's Session has started.
    ## Do some initialization within our Emitter, for example
  }

  sub s_increment_count {
    my ($kernel, $self) = @_[KERNEL, OBJECT];
    $_[HEAP]->{count} += $_[ARG0] || 1;
    $self->emit( 'counter_incremented', $_[HEAP]->{count} );
  }

Of course, it is still possible to pass in attribute definitions at 
construction time:

  ## In a frontend, for example
  ## Set an alias and a plugin registration prefix:
  my $emitter = My::Emitter->new(
    alias  => 'MyEmitter',
    register_prefix => 'Plug_',
  );

See L<MooX::Role::POE::Emitter/"Attributes"> for more details on 
configuration-related attributes.

=head3 Setting an alias

Giving your Emitter's L<POE::Session> a human-parsable L<POE> C<alias> can 
make it easier to post events without directly keeping track of your 
Emitter's object. This is something you might normally do at 
construction time / before spawn-time from whatever external 
controller/frontend spawns the Emitter:

  ## From a frontend or controller of some sort, for example:
  my $emitter = My::Emitter->new(
    alias => 'my_emitter',
  );

(If an alias is not set, it will default to the 'stringified' 
representation of your Emitter's object.)

You can always retrieve the current alias given the Emitter's object via 
the C<alias> attribute:

  my $alias = $emitter->alias;

This can be used to post events to the Emitter:

  ## Like calling emit(), but using POE dispatch directly:
  my $alias = $emitter->alias;
  $poe_kernel->post( $alias, 'emit', $event, @args );

... as can the L<POE::Session>'s C<session_id> of a running Emitter:

  my $sess_id = $emitter->session_id;
  $poe_kernel->post( $sess_id, 'emit', $event, @args );

The C<alias> can be reset on-the-fly, if needed:

  $emitter->set_alias( $new_alias );

=head3 Configuring prefixes

Your emitter has a few different prefix types that are configurable:

=over

=item event_prefix

The B<event_prefix> is prepended to emitted events that 
are dispatched to subscribed listening Sessions.

For example, if B<event_prefix> is 'emitted_' (the default prefix), 
C<$emitter->emit('my_event')> will dispatch 'emitted_my_event' to 
subscribed listener sessions.

=item register_prefix

The B<register_prefix> is the prefix prepended to registration events; this 
is really for use by L<MooX::Role::Pluggable> (see 
L</MooX::Role::Pluggable/"_pluggable_init"> for more details) -- the 
B<register_prefix> is prepended to 'register' and 'unregister' events 
dispatched to plugins at load-time.

We'll demonstrate plugin registration handler methods in the section below 
regarding L</"PLUGINS">.

=item pluggable_type_prefixes

The Emitter is aware of two different L<MooX::Role::Pluggable> 
'event types': C<PROCESS> (events that are synchronously plugin-processed 
only) and C<NOTIFY> (events that are synchronously or asynchronously 
dispatched to plugins and subscribed listening Sessions).

The default prefix for a C<NOTIFY> event is C<N>. 
The default for a C<PROCESS> event is C<P>.

You can alter the prefixes via a hash reference passed to 
B<pluggable_type_prefixes>:

  ## Configured via constructor, for example:
  my $emitter = My::Emitter->new(
    pluggable_type_prefixes => {
      PROCESS => 'Proc',
      NOTIFY  => 'Notify',
    },
  );

These prefixes automatically have a '_' appended when used:

  ## Given a NOTIFY prefix of "Notify":
  $emitter->emit('my_event');
  ## --> Dispatched to the Emitter and its plugins as 'Notify_my_event'

We'll cover L</"PROCESS vs NOTIFY"> a bit more when we demonstrate plugins.

=back

FIXME construction/config examples?

=head3 Adding Emitter states

Unless your class is just a bare Emitter intended to broadcast 
externally-fed events to plugins and listeners, it will probably do some 
work internally via its own states. At the very least, you might want to 
map the C<emitter_started> event to some handler.

Earlier, we showed an 'increment_count' state that was mapped to the 
's_increment_count' method via C<object_states>. (It's important to note 
that these object_states have to be defined before C<_start_emitter> is 
called -- it's actually possible to execute anonymous code references as 
if they were predefined states, however; see L</"Dispatch within the 
Emitter">)

A POE handler looks a little different than the average subroutine; 
parameters are given names (that are actually constants imported when you 
C<use POE;>):

  sub my_event {
    ## The POE::Kernel and the object this event was dispatched to:
    my ($kernel, $self) = @_[KERNEL, OBJECT];
    ## The arguments passed to this event:
    my @params = @_[ARG0 .. $#_];
    . . .
  }

See L<POE::Session/"USING POE::Session"> from the POE documentation for 
more details on what a normal POE state belonging to a Session might look 
like.

There are sugary methods provided for triggering these Emitter states. 
L</"Dispatch within the Emitter"> contains most of the details.

=head2 Starting your Emitter

Your Emitter's L<POE::Session> is created when _start_emitter is called; a 
frequent pattern is to provide some method that specifically starts the 
Emitter:

  ## A spawn() method in your Emitter class:
  sub spawn {
    my ($self) = @_;
    $self->_start_emitter;
  }

The L<POE::Session> is spawned immediately if the L<POE::Kernel> is already 
running; otherwise it is spawned whenever L<POE::Kernel>'s C<run()> method 
is called (typically from a frontend of some sort or similar). Refer back 
to the section on L</POE> for details.

When the Emitter starts, it will issue itself an 'emitter_started' POE 
event with no arguments. In L</Configuration>, we demonstrated installing 
an 'emitter_started' handler via the C<object_states> attribute; refer back 
to that section for a brief example.

=head2 Emitting events

Once the Emitter's Session is started, your object can begin emitting 
events via C<emit()> (or its synchronous counterpart C<emit_now()>.

Any piece of code that knows about the Emitter object can tell it to emit 
arbitrary events to subscribed listeners:

  ## Dispatched asynchronously:
  $emitter->emit( $event, @args );
  ## Dispatched now:
  $emitter->emit( $event, @args );

Loading plugins is optional, but if they are loaded, emitted events 
are dispatched to the Emitter's session first, then to loaded 
plugins, then (if the event wasn't eaten by plugins, which we'll cover in  
L</"Controlling event lifetime">) broadcast to subscribed listeners.

Emitted events are called "NOTIFY" events in conjunction with 
the plugin pipeline provided by L<MooX::Role::Pluggable> -- this is in 
contrast to "PROCESS" type events, which are plugin-processed 
immediately but never sent to subscribed 
listeners.

=head2 Dispatch within the Emitter

Your Emitter comes with convenient methods for dispatching events within 
the context of the Emitter itself; that is to say, dispatching defined 
C<object_states> and even executing anonymous subroutines as if they were 
named POE states.

For example, our Emitter as shown in L</Configuration> defined an 
'increment_count' state and a handler for it that just increments a 
variable in the L<POE::Session>'s HEAP and emits 
'counter_incremented' with the new value as an argument.

We could externally invoke the Emitter's handler asynchronously via 
C<yield()>:

  $emitter->yield( 'increment_count', 2 );

... or synchronously via C<call()>:

  $emitter->call( 'increment_count', 2 );

Of course, this only works for POE states that are predefined in your 
Emitter. C<yield()> and C<call()> actually accept anonymous code references 
as well, which are executed just as if they were named states:

  ## Re-implement our increment_count state as a coderef:
  $emitter->yield(
    sub {
       ## $_[OBJECT] is our Emitter's object:
       my ($kernel, $self) = @_[KERNEL, OBJECT];
 
       ## $_[STATE] is this code reference itself:
       my $cb = $_[STATE];

       ## $_[HEAP] is our Emitter's POE::Session's heap:
       $_[HEAP]->{count} += $_[ARG0] || 1;
       $self->emit( 'counter_incremented', $_[HEAP]->{count} );
    },
    2
  );

=head3 Timers

The L<POE::Kernel> provides its own timer/delay mechanisms, but your 
Emitter comes with some sugar for issuing timed events that will execute in 
the context of the running Emitter.

For example, you can C<emit()> events on a timer:

  my $timer_id = $emitter->timer(
    $delay_seconds,
    'emit',
    $some_event,
    @event_args
  );

Perhaps your Emitter might have set up some C<object_states> for itself 
(refer back to L</Configuration>) and you'd like to fire one of your 
custom handlers at some point in the future:

  $emitter->timer( $delay, 'my_event', @args );

Just like C<yield>, C<timer> can take an anonymous callback code-reference 
instead, which will receive itself via $_[STATE]:

  $emitter->timer(
    $delay,
    sub {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      my $callback  = $_[STATE];
      my $first_arg = $_[ARG0];
      ## ... do some work, set $new_arg perhaps ...
      ## Reset this same timed callback, as an example:
      $self->timer( $delay, $callback, $new_arg );
    },
    $some_arg
  );

C<timer()> returns the timer ID, which can be fed to C<timer_del> to clear 
this timer if needed:

  $emitter->timer_del( $timer_id );

=head2 Stopping your Emitter

Unlike a normal L<POE::Session>, which goes away if it has no alias and 
nothing to do, your Emitter's Session only shuts down when it is told to.

To make clean shutdowns easier, your Emitter may want to provide a 
C<shutdown> method or similar that calls C<_shutdown_emitter> (and perhaps 
does some other cleanup):

  ## In your Emitter:
  sub shutdown {
    my ($self) = @_;
    ## Do other cleanup, etc.
    $self->_shutdown_emitter;
  }

Calling C<_shutdown_emitter> will unregister subscribed listening Sessions, 
stop timers, clear the plugin pipeline, and reduce the Emitter's L<POE> 
reference count so that the Session can go away naturally.

FIXME dispatched shutdown-related events
FIXME shutdown_emitter events, ->_shutdown_emitter

=head1 PLUGINS

Since consuming L<MooX::Role::POE::Emitter> also brings in 
L<MooX::Role::Pluggable>, your Emitter comes with a plugin pipeline and 
various methods to manipulate it, which are documented in 
L<MooX::Role::Pluggable>.

Plugins are an optional way to extend your Emitter on-the-fly. Plugin 
objects can control an event's lifetime and modify arguments (or even drop 
events entirely) prior to broadcasting events to subscribed listener 
Sessions.

A plugin is just an object that provides register/unregister methods 
called by L<MooX::Role::Pluggable> when the plugin is loaded/unloaded; 
the plugin can subscribe to events during or after registration and define 
methods to handle them.

=head2 Adding plugins to the Emitter

FIXME brief plugin_add/plugin_del coverage, emitted plugin_added?
FIXME event subscribe() for PROCESS and NOTIFY

=head2 PROCESS vs NOTIFY

There are two types of events dispatched to plugins via 
L<MooX::Role::Pluggable/"_pluggable_process"> by an Emitter: B<PROCESS> and 
B<NOTIFY>.

A B<PROCESS> event is dispatched when the Emitter's C<process()> method is 
called. These are events that are only processed (synchronously) by 
plugins, in contrast to emitted events. By default, handlers for these 
events

A B<NOTIFY> event is dispatched to plugins when the C<emit()> or 
C<emit_now()> methods are used to emit events.
Plugin processing happens directly before events are emitted 
to listening sessions.

In either case, arguments can be modified (see L</"Pluggable handler 
arguments">, below) and the event's lifetime can be controlled via event handler 
return values (which we'll cover in L</"Controlling event lifetime">, also 
below).

It's worth noting that a plugin event is actually first dispatched to 
the Emitter's object if a handler method for it is defined. For example, 
given the default B<PROCESS> prefix 'P':

  ## A PROCESS event handler defined in your Emitter:
  use MooX::Role::Pluggable::Constants;
  sub P_my_event {
    ## First and second args are both $self inside the Emitter:
    my ($self) = splice @_, 0, 2;

    ## Explicit de-reference
    ##  (see 'Pluggable handler arguments' below)
    my $first_arg = ${ $_[0] };

    . . .

    ## Let this event continue to plugins
    ##  (see 'Controlling event lifetime' below)
    return EAT_NONE
  }

(See L<MooX::Role::Pluggable> for complete details on plugin dispatch.)

=head2 Pluggable handler arguments

An event handler inside a plugin receives its arguments as 
individual references; this means they can be modified as the event is 
handed down through the plugin pipeline:

  sub P_my_process_event {
    ## First two arguments are the plugin's '$self'
    ## and the Emitter object, respectively:
    my ($self, $emitter) = splice @_, 0, 2;

    ## Any other arguments are scalar references:
    my $first  = ${ $_[0] };
    my $second = ${ $_[1] };

    ## ... another way:
    my ($first, $second) = @_;
    $$first = "New string";

    return EAT_NONE
  }

You can control the order of plugins within the pipeline, thereby making it 
easy to insert filters that operate on arguments before other plugins, for 
example. See L<MooX::Role::Pluggable> for details on plugin pipeline 
manipulation.

=head2 Controlling event lifetime

The above examples show handlers returning C<EAT_*> constants.
These are brought in when your plugin (or Emitter) imports 
L<MooX::Role::Pluggable::Constants>:

  package MyPlugin;
  use strictures 1;
  ## Get the following constants:
  ##  EAT_NONE, EAT_ALL, EAT_PLUGIN, EAT_CLIENT
  use MooX::Role::Pluggable::Constants;

The most common return values are 'EAT_NONE' (indicating the event should 
continue to the next plugin in the pipeline and/or off to listening 
Sessions) and 'EAT_ALL' (indicating the event's lifetime should terminate).

EAT_PLUGIN is used to stop plugins from processing but 
allow the event to continue to listening Sessions. EAT_CLIENT is the 
opposite, allowing plugin processing but skipping dispatch to listening 
Sessions.

More details can be found in the documentation for  
L<MooX::Role::POE::Emitter/"emit"> and L<MooX::Role::Pluggable>.

=head2 Writing a plugin


FIXME brief example with register handlers and a P_ / N_ handler

=head1 LISTENERS

=head2 Creating a listener Session

A listener/subscriber is just a regular L<POE::Session> that sends a 
C<subscribe> event to your Emitter for some set of events (or 'all' -- 
see L</"Subscribing to emitted events">, below).

For example, here's a complete listener as a Moo class. It creates a 
L<POE::Session> when ->spawn() is called and subscribes to receive all 
events.

  package My::Listener;
  use POE;
  use Moo;

  ## This listener is told about the Emitter's object at
  ## construction time (but it doesn't have to be -- one could
  ## just as easily pass the Emitter's object, alias, or Session
  ## ID to a spawn() method instead):
  has 'emitter' => (
    is       => 'ro',
    required => 1
  );

  ## ->spawn() will start the listener's Session.
  sub spawn {
    my ($self) = @_;

    ## Set up a POE::Session with some states defined as methods
    ## called on the '$self' object:
    POE::Session->create(
      object_states => [
        $self => [
          '_start',
          'emitted_event_one',
          'emitted_event_two',
        ],
      ],
    );
  }

  sub _start {
    my ($kernel, $self) = @_[KERNEL, OBJECT];

    ## Subscribe to all events when the listener's Session starts.

    $kernel->post( $self->emitter->session_id,
      'subscribe',
      'all'
    );
  }

  sub emitted_event_one {
    my ($kernel, $self) = @_[KERNEL, OBJECT];
    my $first_arg = $_[ARG0];

    . . .

    ## Emit event_two, for example
    $self->emitter->emit( 'event_two', $first_arg );
  }

  sub emitted_event_two {
    my ($kernel, $self) = @_[KERNEL, OBJECT];
    my @args = @_[ARG0 .. $#_];

    . . .
  }

=head2 Subscribing to emitted events

Posting a 'subscribe' event to the Emitter's Session (via alias or 
session_id) registers to receieve events:

FIXME elaboration
FIXME notes on unsubscribe 'all' vs empty unsubscribe?

=head2 Receiving events

FIXME

=head1 AUTHOR

Jon Portnoy <avenj@cobaltirc.org>

=cut
