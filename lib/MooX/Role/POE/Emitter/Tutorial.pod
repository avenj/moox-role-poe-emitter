=pod

=head1 NAME

MooX::Role::POE::Emitter::Tutorial

=head1 SYNOPSIS

A L<MooX::Role::POE::Emitter> walk-through aimed at developers who may not 
have strong POE/Moo(se) background.

Some familiarity with object-oriented concepts is assumed.

=head1 INTRODUCTION

There are a few concepts and modules you will want to review prior to 
using this role in your class(es):

=head2 Moo

L<Moo> is a minimalist alternative to L<Moose>, providing all the 
class-building goodies in a L<Moose>-compatible manner without the extra 
overhead of a Meta-Object Protocol (MOP).

See L<Moo> for details.

=head2 Roles

A role is a well-defined implementation of what some languages call 
"mix-ins" or sometimes possibly "traits." A role defines something a class 
B<does>; in other words, encapsulated methods & attributes that do not form 
a concrete class on their own, but can be "consumed" by a class to add some 
behavior (such as "emits events").

See L<Moo::Role> and L<Role::Tiny> for details.

=head2 POE

L<POE> is a framework for event-driven asynchronous systems; it is the 
granddaddy of Perl event frameworks.

L<http://poe.perl.org> contains extensive documentation and examples.

L<POE>, L<POE::Kernel>, and L<POE::Session> are helpful reads, at the very 
least.

=head3 POE Kernel

The L<POE::Kernel> is a bit like an operating system kernel, 
managing the L<POE::Loop> and providing central bookkeeping and 
event/signal dispatch functionality.

=head3 POE Sessions

We stated above that the L<POE::Kernel> is conceptually similar to an 
operating system kernel. In that sense, a L<POE::Session> could be thought 
of as being like a process -- the Session asynchronously receives events 
(often called "states") posted to it by itself or other Sessions and 
performs some action defined in an assigned handler.

These handlers or 'states' are defined via POE mechanisms known as 
C<inline_states> (states assigned to inlined coderefs), C<package_states> 
(states assigned to a particular package name), and (most importantly for 
our purposes) C<object_states>. See L</Adding Emitter states> for more on 
C<object_states> as pertains to your Emitter and the L<POE::Session> 
documentation for the details.

L<POE> events are typically sent asynchronously between Sessions in a 
one-to-one manner; 
L<MooX::Role::POE::Emitter> makes it possible to post events to an 
arbitrary number of interested "listener" Sessions in a one-to-many fashion 
instead.

Your Emitter is automatically given its own L<POE::Session> when it is 
started. Sessions that have already been defined are run when 
L<POE::Kernel>'s C<run()> method is called; Sessions can be created on the 
fly, as well, in which case they are spawned when they are created via 
L<POE::Session>'s C<create()> method.

FIXME note about named arguments? somewhere ...

=head2 Observer Pattern

The design pattern implemented in this Role is described as "Observer 
Pattern" -- a term for a design approach in which "observer" 
objects are automatically notified/updated when another object changes 
state.

This particular implementation is derived from 
L<POE::Component::Syndicator>-0.06.

=head1 EMITTERS

=head2 Outline

Since this is a Role, not a class unto itself, the first step in creating 
an Emitter is to define your class:

  package My::Emitter;
  use Moo;
  use POE;
  with 'MooX::Role::POE::Emitter';

The above snippet is actually enough to have a working Emitter with default 
options and no built-in states; you could just stop reading right there ;-)

=head2 Configuration

That might not be quite enough; we may want named L<POE> states built 
into our Emitter that we can trigger, and/or we may want to change some 
configuration options, assign an C<alias> that L<POE> will 
recognize, etc.

=head3 BUILD vs construction-time

There are a couple different approaches to configuring your Emitter.

Your Emitter could define a C<BUILD> method or some other method (the 
SYNOPSIS of L<MooX::Role::POE::Emitter> uses C<spawn>) that performs some 
set-up after the object is constructed. Here's an example that adds a 
handler for the internal 'emitter_started' L<POE> event dispatched to the 
Emitter when it is started; we'll go into more depth on C<object_states> 
later:

  package My::Emitter;
  use Moo;
  use POE;
  with 'MooX::Role::POE::Emitter';

  sub BUILD {
    my ($self) = @_;

    ## Add some object_states, for example
    ## We'll cover this further later on.
    $self->set_object_states(
      [
        $self => {
          'emitter_started' => '_emitter_started',
        },

        ## Include any object_states that were added at
        ## construction time (or by a subclass, etc)
        (
          $self->has_object_states ?
            @{ $self->object_states } : ()
        ),
      ],
    );
  }
  
  sub spawn {
    my ($self) = @_;
    ## Start our Emitter's Session. We could do this in BUILD to cause the
    ## Session to be immediately created, but providing a spawn() method
    ## gives us a little more external control:
    $self->_start_emitter;
  }

  sub _emitter_started {
    my ($kernel, $self) = @_[KERNEL, OBJECT];
    ## Our Emitter's Session has started.
    ## Do some initialization within our Emitter, for example
  }

Of course, it is still possible to pass in attribute definitions at 
construction time:

  ## In a frontend, for example
  ## Set an alias and a plugin registration prefix:
  my $emitter = My::Emitter->new(
    alias  => 'MyEmitter',
    register_prefix => 'Plug_',
  );

See L<MooX::Role::POE::Emitter/"Attributes"> for more details on 
configuration-related attributes.

=head3 Setting an alias

Giving your Emitter's L<POE::Session> a human-parsable L<POE> C<alias> can 
make it easier to post events without directly keeping track of your 
Emitter's object. This is something you might normally do at 
construction time / before spawn-time from whatever external 
controller/frontend spawns the Emitter:

  ## From a frontend or controller of some sort, for example:
  my $emitter = My::Emitter->new(
    alias => 'my_emitter',
  );

(If an alias is not set, it will default to the 'stringified' 
representation of your Emitter's object.)

You can always retrieve the current alias given the Emitter's object via 
the C<alias> attribute:

  my $alias = $emitter->alias;

This can be used to post events to the Emitter:

  ## Like calling emit(), but using POE dispatch directly:
  my $alias = $emitter->alias;
  $poe_kernel->post( $alias, 'emit', $event, @args );

... as can the L<POE::Session>'s C<session_id> of a running Emitter:

  my $sess_id = $emitter->session_id;
  $poe_kernel->post( $sess_id, 'emit', $event, @args );

The C<alias> can be reset on-the-fly, if needed:

  $emitter->set_alias( $new_alias );

=head3 Configuring prefixes

Your emitter has a few different prefix types that are configurable:

=over

=item event_prefix

The B<event_prefix> is prepended to emitted events that 
are dispatched to subscribed listening Sessions.

For example, if B<event_prefix> is 'emitted_' (the default prefix), 
C<$emitter->emit('my_event')> will dispatch 'emitted_my_event' to 
subscribed listener sessions.

=item register_prefix

The B<register_prefix> is the prefix prepended to registration events; this 
is really for use by L<MooX::Role::Pluggable> (see 
L</MooX::Role::Pluggable/"_pluggable_init"> for more details) -- the 
B<register_prefix> is prepended to 'register' and 'unregister' events 
dispatched to plugins at load-time.

FIXME link to more on plugin register handlers in plugins section

=item pluggable_type_prefixes

FIXME quickly explain process() vs emit() + PROCESS vs NOTIFY
      links down to Plugin section and MooX::Role::Pluggable

=back

FIXME construction/config examples?

=head3 Adding Emitter states

FIXME demonstrate object_states
FIXME note about dispatch to Emitter session if registered
FIXME link to notes about anon CBs standing in stead of named states

=head2 Starting your Emitter

Your Emitter's L<POE::Session> is created when _start_emitter is called; a 
frequent pattern is to provide some method that specifically starts the 
Emitter:

  ## A spawn() method in your Emitter class:
  sub spawn {
    my ($self) = @_;
    $self->_start_emitter;
  }

The L<POE::Session> is spawned immediately if the L<POE::Kernel> is already 
running; otherwise it is spawned whenever L<POE::Kernel>'s C<run()> method 
is called (typically from a frontend of some sort or similar). Refer back 
to the section on L</POE> for details.

When the Emitter starts, it will issue itself an 'emitter_started' POE 
event with no arguments. In L</Configuration>, we demonstrated installing 
an 'emitter_started' handler via the C<object_states> attribute; refer back 
to that section for a brief example.

=head2 Emitting events

FIXME emit, emit_now, process with links to plugins section

=head2 Dispatch within the Emitter

FIXME yield, call, anon CBs, mention ->timer($delay, 'emit', $event) etc

=head3 Timers

FIXME timer(), timer_del(), emitted notifications

For example, you can C<emit()> events on a timer:

  my $timer_id = $emitter->timer(
    $delay_seconds,
    'emit',
    $some_event,
    @event_args
  );

FIXME demonstrate timer resetting itself

=head2 Stopping your Emitter

Unlike a normal L<POE::Session>, which goes away if it has no alias and 
nothing to do, your Emitter's Session only shuts down when it is told to.

To make clean shutdowns easier, your Emitter may want to provide a 
C<shutdown> method or similar that calls C<_stop_emitter> (and perhaps does 
some other cleanup):

  ## In your Emitter:
  sub shutdown {
    my ($self) = @_;
    ## Do other cleanup, etc.
    $self->_stop_emitter;
  }

Calling C<_stop_emitter> will unregister subscribed listening Sessions, 
stop timers, clear the plugin pipeline, and reduce the Emitter's L<POE> 
reference count so that the Session can go away naturally.

FIXME dispatched shutdown-related events
FIXME shutdown_emitter events, ->_stop_emitter

=head2 A complete Emitter

FIXME show a complete Emitter implementation with comments, based on above 
bits

=head1 PLUGINS

FIXME brief outline and links back to MooX::Role::Pluggable

Since consuming L<MooX::Role::POE::Emitter> also brings in 
L<MooX::Role::Pluggable>, your Emitter comes with a plugin pipeline and 
various methods to manipulate it, which are documented in 
L<MooX::Role::Pluggable>.

Plugins are an optional way to extend your Emitter on-the-fly. Plugin 
objects can control an event's lifetime and modify arguments (or even drop 
events entirely) prior to broadcasting events to subscribed listener 
Sessions.

=head2 Adding plugins to the Emitter

FIXME brief plugin_add/plugin_del coverage, emitted plugin_added?

=head2 Pluggable handler arguments

FIXME notes on modifying arguments, references, etc

=head2 Controlling event lifetime

FIXME brief notes on EAT_* constants

=head2 Writing a plugin

FIXME brief example with register handlers and a P_ / N_ handler

=head1 LISTENERS

=head2 Creating a listener Session

=head2 Subscribing to emitted events

=head2 Receiving events

=head1 COMPLETION

FIXME full app, test it

=head1 AUTHOR

Jon Portnoy <avenj@cobaltirc.org>

=cut
